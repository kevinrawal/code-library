"""authentication route"""

from datetime import datetime, timedelta, timezone

import sys
import os
import dotenv
from typing import Annotated

from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordRequestForm

from jose import jwt, JWTError
from passlib.context import CryptContext
from pydantic import BaseModel

from models.users import User
from services.user_services import get_user_from_db

# THIS CODE IS TO ACCESS MODULES OUTSIDE ROUTE
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

dotenv.load_dotenv()

#TODO - use different secrete key for refresh token and access token
SECRET_KEY = os.environ["SECRET_KEY"]
ALGORITHM = os.environ["ALGORITHM"]

#TODO - Change Refresh Token Expiration, set in env 
ACCESS_TOKEN_EXPIRE_MINUTES = 100
REFRESH_TOKEN_EXPIRE_MINUTES = 200

router = APIRouter()


class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def verify_password(plain_password, hashed_password):
    """Verify plain password with hashed password"""
    return pwd_context.verify(plain_password, hashed_password)


async def authenticate_user(email_id: str, password: str) -> dict:
    """Authenticate user based on provided email id and password,
       it matches with database hashed password and return user

    Args:
        email_id (str):
        password (str):

    Returns:
        dict: return user if user is authenticated else return None
    """
    user = await get_user_from_db(email_id)
    if user is not None and verify_password(password, user["password"]):
        return user
    return None

async def authorize_user_by_refresh_token(refresh_token: str, email_id: str) -> bool:
    """Authorize user via refresh token

    Args:
        refresh_token (str): _description_
        email_id (str): _description_

    Returns:
        bool: _description_
    """
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        email_id_from_token = payload.get("email_id")
        return email_id == email_id_from_token
    except JWTError:
        return False

def create_access_token(data: dict, expires_delta: timedelta):
    """create jwt token for the user

    Args:
        data (dict): has user_id = unique _id generated by system for each user
        expires_delta (timedelta): time to expire the jwt token

    Returns:
        Token: jwt token
    """
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + expires_delta
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict, expires_delta: timedelta):
    """create jwt refresh token for the user

    Args:
        data (dict): has user_id = unique _id generated by system for each user
        expires_delta (timedelta): time to expire the jwt token

    Returns:
        Token: jwt token
    """
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + expires_delta
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

@router.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
) -> Token:
    """This Route is used to authenticate user and return access token

    Args:
        user (User): user model given by the end user

    Raises:
        HTTPException: credecial exception

    Returns:
        Token: jwt aceess token
    """
    # form data has username and password filed,
    # we need to convert it into user object before moving forward
    user = User(email_id=form_data.username, password=form_data.password)

    user_in_db = await authenticate_user(user.email_id, user.password)
    if user_in_db is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect userid or password",
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token_expires = timedelta(minutes=REFRESH_TOKEN_EXPIRE_MINUTES)
    
    access_token = create_access_token(
        data={"user_id": user_in_db["_id"], "email_id": user_in_db["email_id"]},
        expires_delta=access_token_expires,
    )

    #TODO - refresh token should me more sequre.
    refresh_token = create_refresh_token(
        data={"email_id": user_in_db["email_id"]},
        expires_delta=refresh_token_expires,
    )
    return Token(access_token=access_token, refresh_token=refresh_token, token_type="bearer")

@router.post("/token/refresh")
async def refresh_access_token(refresh_token: str, email_id: str):
    """Generate new access token from refresh token

    Args:
        refresh_token (str): _description_
        email_id (str): _description_

    Raises:
        HTTPException: _description_

    Returns:
        _type_: _description_
    """
    user_in_db = await get_user_from_db(email_id)
    if authorize_user_by_refresh_token(refresh_token, email_id) is False or user_in_db is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token",
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"user_id": user_in_db["_id"], "email_id": user_in_db["email_id"]},
        expires_delta=access_token_expires,
    )

    return {"access_token": access_token}
